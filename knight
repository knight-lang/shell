#!/bin/dash

################################################################################
#                                    Setup                                     #
################################################################################

## Set options
set -o nounset
set -o noglob

# Naming scheme:
# READ_ONLY
# Global_Variables
# local_variable
# _variable_that_doesnt_need_to_be_local

## Values:
# i-?\d+                   - integer
# s.*                      - string
# [TFN]                    - true/false/null
# v[a-z_][a-z0-9_]         - variable
# a(\d+)(${ARY_SEP}value)* - array; \1 is len, \2+ is elements. value cannot be an ast
# A(\d+)                   - array ref; `eval`ing it will give you the original array
# f(.)(${FN_SEP}value)*    - function; \1 is name, \2+ are arguments.
# F(\d+)                   - fn ref, `eval`ing it will give you the original AST
##

readonly ARY_SEP=: # "$(printf %d \'28)"
readonly FN_SEP=\( # "$(printf %d \'29)"; needs to be diff from ARY_SEP
readonly SCRIPT_NAME=${0##*/}
readonly NEWLINE='
'

## Print out a message and exit the program
die () {
	fmt=$1
	shift
	printf "%s: $fmt\\n" "$SCRIPT_NAME" "$@"
	exit 1
}

TODO () { die "TODO: $*"; }

################################################################################
#                                    Arrays                                    #
################################################################################

Next_Ary_Ref_Idx=0

new_ary () {
	Reply=a$#

	for _arg; do
		if [ "${_arg#a}" = "$_arg" ]; then
			Reply=$Reply$ARY_SEP$_arg
		else
			# readonly
			eval "A$Next_Ary_Ref_Idx=\$_arg"
			Reply=$Reply${ARY_SEP}A$Next_Ary_Ref_Idx
			Next_Ary_Ref_Idx=$((Next_Ary_Ref_Idx + 1))
		fi
	done
}

alias explode-array-at-arg1='
_old_IFS=$IFS
IFS=$ARY_SEP
set -o noglob
set -- $1
shift # delete `aN` prefix
set +o noglob
IFS=$_old_IFS
'

ary_join () {
	# We have to have `result` be local because `to_str` will clobber `Reply`.
	local sep=$1 result=
	shift

	explode-array-at-arg1

	for _arg; do
		to_str "$_arg"
		result=$result${result:+$sep}$Reply
	done

	Reply=$result
}

################################################################################
#                                 Conversions                                  #
################################################################################

## Converts its argument to a string, storing the result in $Reply
to_str () case $1 in
	[si]*) Reply=${1#?} ;;
	T)     Reply=true ;;
	F)     Reply=false ;;
	N)     Reply= ;;
	A*)    eval "to_str \$$1" ;;
	a*)    ary_join "$NEWLINE" "$1" ;;
	[fFv]*) run "$1"; to_str "$Reply" ;;
	*) die "unknown type for to_str: $1" ;;
esac

## Converts its argument to an integer, storing the result in $Reply
to_int () case $1 in
	s*) case ${1%s} in
		-*[!0-9]*) TODO ;;
		[!-]*[!0-9]*) TODO ;;
		*) Reply=i${1%s} ;; # TODO: there's no way this works
		esac ;;
	[FN]) Reply=0 ;;
	T)    Reply=1 ;;
	i*)   Reply=${1#i} ;;
	A*)   eval "to_int \$$1" ;;
	a*)   Reply=${1#a}
	      Reply=${Reply%%"$ARY_SEP"*} ;;
	[fFv]*) run "$1"; to_int "$Reply" ;;
	*) die "unknown type for to_int: $1" ;;
esac

## Returns 0 if its argument is truthy
to_bool () case $1 in [sFN]|[ia]0) false;; [fFv]*) run "$1"; to_bool "$Reply"; esac

# Converts its argument to an array, storing the result in $Reply
to_ary () case $1 in
	[sFN]) Reply=a0 ;; # Note that we handle the empty string case here
	T) Reply=a1:T ;;
	s*) _str=${1#s}
		Reply=a${#_str}
		while [ -n "$_str" ]; do
			Reply=$Reply${ARY_SEP}s$(printf %c "$_str")
			_str=${_str#?}
		done ;;
	A*)    eval "to_ary \$$1" ;;
	a*)    Reply=$1 ;;
	[fFv]*) run "$1"; to_ary "$Reply" ;;
	*) die "unknown type for $0: $1" ;;
esac

################################################################################
#                                  Utilities                                   #
################################################################################

## Sets `Reply` to `T` or `F` based on the exit status of the last command.
newbool () if [ $? -ne 0 ]; then Reply=F; else Reply=T; fi

## Dumps its argument to stdout.
dump () case $1 in
	T) printf true ;;
	F) printf false ;;
	N) printf null ;;
	i*) printf ${1#i} ;;
	s*) printf %sx "${1#s}" | sed '
:s
$!N;$!bs
s/\\/\\\\/g;s/\t/\\t/g;s/\r/\\r/g;s/"/\\"/g;s/\n/\\n/g
s/^/"/; s/x$/"/' ;;
	a0) printf \[\] ;;
	a*) 
		printf \[
		explode-array-at-arg1

		dump "$1"; shift
		for _arg; do
			printf ', '
			dump "$_arg"
		done
		printf \]
		;;
	A*) eval "dump \$$1" ;;
	[fFv]*) printf '[%s]' "$1" ;;
	*) die "unknown type for dump: $1" ;;
esac

## Returns whether its arguments are equal, ie knight's `?` function
are_equal () {
	# expand out `A` references
	[ "${1#A}" != "$1" ] && eval "set -- \$$1 \$2"
	[ "${2#A}" != "$2" ] && eval "set -- \$1 \$$2"

	# If they're identical, then they're equal.
	[ "$1" = "$2" ] && return


	# If either element isn't an array, then they're not equal; arrays are the
	# only type which require more than a simple `=` comparison
	if [ "${1#a}" = "$1" ] || [ "${2#a}" = "$2" ]; then
		return 1
	fi

	# They're both arrays. Given how we've checked for direct equality, the only
	# things that we need to check for now are `A*`s. We also can't explode, as
	# we have two arrays to deal with. lovely :-(

	while [ -n "$1" ] && [ -n "$2" ]; do
		_prefix1="${1%%"$ARY_SEP"*}"; _tmp1=${1#"$_prefix1"}; _tmp1=${_tmp1#"$ARY_SEP"}
		_prefix2="${2%%"$ARY_SEP"*}"; _tmp2=${2#"$_prefix2"}; _tmp2=${_tmp2#"$ARY_SEP"}
		set -- "$_tmp1" "$_tmp2"

		# Hey they're the same, we're good!
		[ "$_prefix1" = "$_prefix2" ] && continue

		# Hm, one of them isn't a reference, looks like they're not the same
		if [ "${_prefix1#A}" = "$_prefix1" ] || [ "${_prefix1#A}" = "$_prefix1" ]; then
			return 1
		fi

		# Both are references, test them out
		are_equal "$_prefix1" "$_prefix2" || return
	done
}

## Sets $Reply to `-1`, `0`, or `1` depending on whether the first argument is
# smaller than, equal to or greater than the second argument.
compare () case $1 in
	s*) to_str "$2"; if [ "${1#s}" \< "$Reply" ]; then
			Reply=-1
		else
			[ "${1#s}" = "$Reply" ]
			Reply=$?
		fi ;;
	T) to_bool "$2"; Reply=$?;;
	F) to_bool "$2"; Reply=$(( - ! $? ));; # The `?` here is actually `$?`
	i*) to_int "$2"; if [ "${1#i}" -lt "$Reply" ]; then
			Reply=-1
		else
			[ "${1#i}" -eq "$Reply" ]
			Reply=$?
		fi ;;
	a*) to_ary "$2"

	_prefix1="${1%%"$ARY_SEP"*}"; _tmp1=${1#"$_prefix1"}; _tmp1=${_tmp1#"$ARY_SEP"}
	_prefix2="${2%%"$ARY_SEP"*}"; _tmp2=${2#"$_prefix2"}; _tmp2=${_tmp2#"$ARY_SEP"}
	set -- "$_tmp1" "$_tmp2"

	local len1=${_prefix1#a} len2=${_prefix2#a}
	
	while [ -n "$1" ] && [ -n "$2" ]; do
		_prefix1="${1%%"$ARY_SEP"*}"; _tmp1=${1#"$_prefix1"}; _tmp1=${_tmp1#"$ARY_SEP"}
		_prefix2="${2%%"$ARY_SEP"*}"; _tmp2=${2#"$_prefix2"}; _tmp2=${_tmp2#"$ARY_SEP"}
		set -- "$_tmp1" "$_tmp2"

		compare "$_prefix1" "$_prefix2"
		[ $Reply = 0 ] || return 0
	done
	compare i$len1 i$len2 ;;
	*) die "unknown type for compare: $1" ;;
esac

################################################################################
#                                   Parsing                                    #
################################################################################

arity () case $1 in
	[PR]) Reply=0 ;;
	[][\$OEBCQ\!LD,A\~]) Reply=1 ;;
	[-+\*/%\^\?\<\>\&\|\;\=W]) Reply=2 ;;
	[GI]) Reply=3 ;;
	S) Reply=4 ;;
	*) die 'unknown function: %s' "$1" ;;
esac

Next_Fn_Ref_Idx=0
parse_fn () {
	local arity result="f$1"

	arity "$1"
	arity=$Reply

	while [ $arity -ne 0 ]; do
		next_expr || return
		# Expression wasn't an ast, just assign it 
		if [ "${Reply#f}" = "$Reply" ]; then
			result="$result$FN_SEP$Reply"
		else
			# Expression was a function, we have to get a refernece to it
			eval "F$Next_Fn_Ref_Idx=\$Reply"
			result=$result${FN_SEP}F$Next_Fn_Ref_Idx
			Next_Fn_Ref_Idx=$((Next_Fn_Ref_Idx + 1))
		fi

		arity=$(( arity - 1 ))
	done
	Reply=$result
}

Line=
next_expr () {
	# Strip leading whitespace and comments
	while
		Line=$(printf %s "$Line" | sed 's/^[[:blank:]:(){}]*//; /^#/d')
		[ -z "$Line" ]
	do
		IFS= read -r Line
	done

	# Parse out the token
	case $Line in
		# Integers; cant use `0-9` cause it's locale-dependent technically
		[0123456789]*)
			Reply=i${Line%%[!0123456789]*}
			Line=${Line#"${Reply#?}"} ;;

		# Variables
		[abcdefghijklmnopqrstuvwxyz_]*)
			Reply=v${Line%%[!abcdefghijklmnopqrstuvwxyz_0123456789]*}
			Line=${Line#"${Reply#?}"} ;;

		# Strings; this have to be handled specially cause of multilined stuff
		[\'\"]*)
			_quote=$(printf %c "$Line")
			Line=${Line#?}
			while [ "${Line%$_quote*}" = "$Line" ]; do
				IFS= read -r _tmp || die "missing ending $_quote quote."
				Line=${Line}${NEWLINE}${_tmp}
			done
			Reply=s${Line%%"$_quote"*}
			Line=${Line#"${Reply#s}$_quote"} ;;

		# Functions
		[][TFNPRBCQDOLAWIGSE\$\+\*\/\%\^\<\>\?\&\|\;\~\!\=\,-]*)
			Reply=$(printf %c "$Line")

			case $Reply in
				[TFNPRBCQDOLAWIGSE])
					_tmp=${Line%%[!ABCDEFGHIJKLMNOPQRSTUVWXYZ_]*}
					Line=${Line#"$_tmp"} ;;
				*)
					Line=${Line#?}
			esac

			case $Reply in
				@) Reply=a0 ;;
				[TFN]) ;;
				*) parse_fn "$Reply"
			esac ;;
		*) die "unknown token start: '%c'" "$Line"
	esac
}

## Evaluates the first arg as a knight program, putting the result in $Reply.
eval_kn () {
	# TODO: `exec` with no args to make this a builtin?
	if [ $# = 0 ]; then
		next_expr
	else
		next_expr <<EOS
$1
EOS
	fi || die 'no program given'
	run "$Reply"
}

run () {
	case $1 in
		v*) eval "run \$$1"; return ;; # `set -o nounset` will fail if the var isnt valid
		F?*) eval "run \"\$$1\""; return ;;
		[!f]*) Reply="$1"; return ;;
	esac

	# Explode the arguments
	_old_IFS=$IFS; IFS=$FN_SEP && set -o noglob
	set -- $1 && IFS=$_old_IFS && set +o noglob

	local fn=${1#f}; shift # Fn can be `_fn`

	# Execute functions
	case $fn in
		# Arity 1
		R) TODO "$fn" ;;
		P) TODO "$fn" ;;

		# Arity 2
		B) Reply=$1 ;;
		C) run "$1"; run "$Reply" ;;
		Q) to_int "$1"; exit $Reply ;;
		D) run "$1"; set -- "$Reply"; dump "$1"; Reply="$1" ;;
		O) if to_str "$1"; [ "${Reply%\\}" = "$Reply" ]; then
				printf '%s\n' "$Reply"
			else
				printf '%s' "${Reply%?}"
			fi
			Reply=N ;;
		L) TODO "$fn" ;;
		!) ! to_bool "$1"; newbool ;;
		\~) to_int "$1"; Reply=i$(( - Reply )) ;;
		A) run "$1"; case $Reply in
			s*) Reply=i$(printf %d \'"$Reply") ;;
			i*) TODO ;; #printf '%b\n' '\060' octal ew
			esac ;;
		,) run "$1" ; new_ary "$Reply" ;;
		\[) run "$1"
			case $Reply in
				s*) Reply=s$(printf %c "$Reply") ;;
				[aA]*) TODO "$fn for arrays" ;;
			esac ;;
		\]) run "$1"
			case $Reply in
				s*) Reply=s${Reply#s?} ;;
				[aA]*) TODO "$fn for arrays" ;;
			esac ;;
		E) to_str "$1"; eval_kn "$Reply" ;;
		\$) to_str "$1"; Reply=s$( $Reply ) ;;

		# Arity 2
		\;) run "$1"; run "$2" ;;
		+) run "$1"; set -- "$Reply" "$2"; case $1 in
			i*) to_int "$2"; Reply=i$((${1#?} + Reply)) ;;
			s*) to_str "$2"; Reply=s${1#?}$Reply ;;
			[aA]*) TODO "$fn for arrays" ;;
			*)  die "unknown argument to $fn: $1" ;;
			esac ;;
		-) run "$1"; set -- "$Reply" "$2"; to_int "$2"; Reply=i$((${1#?} - Reply)) ;;
		\*) run "$1"; set -- "$eply" "$2"; case $1 in
			i*) to_int "$2"; Reply=i$((${1#?} + Reply)) ;;
			s*) TODO "$fn for strings" ;;
			[aA]*) TODO "$fn for arrays" ;;
			*)  die "unknown argument to $fn: $1"
			esac ;;
		/) run "$1"; set -- "$Reply" "$2"; to_int "$2"; Reply=i$((${1#?} / Reply)) ;;
		%) run "$1"; set -- "$Reply" "$2"; to_int "$2"; Reply=i$((${1#?} % Reply)) ;;
		^) run "$1"; set -- "$Reply" "$2"; case "$1" in
			i*) to_int "$2"; Reply=i$(echo "${1#?} ^ $Reply" | bc) ;; # no exponents in posix
			[aA]*) TODO "$fn for arrays" ;;
			*)  die "unknown argument to $fn: $1"
			esac ;;
		\?) run "$1"; set --  "$Reply" "$2"; run "$2"; are_equal "$1" "$Reply"; newbool ;;
		\<) run "$1"; compare "$Reply" "$2"; [ $Reply -lt 0 ]; newbool ;;
		\>) run "$1"; compare "$Reply" "$2"; [ $Reply -gt 0 ]; newbool ;;

		G) TODO "$fn" ;;
		S) TODO "$fn" ;;

		=)  run "$2"; eval "$1=\$Reply" ; ;;
		\&) run "$1"; to_bool "$Reply" && run "$2"; ;;
		\|) run "$1"; to_bool "$Reply" || run "$2"; ;;
		W)  while run "$1"; to_bool "$Reply"; do run "$2"; done; Reply=N; ;;
		I)  run "$1"; if to_bool "$Reply"; then run "$2"; else run "$3"; fi ; ;;
		*) die 'unknown function: %s' "$1" ;;
	esac
}


eval_kn <<'EOS'
O ^ 9 3
EOS
run "$Reply"

exit
## Executes a value, and put its result in $Reply
function run {
	## Execute the remaining functions
		## Arity 3
		G) case $1 in
			s*) to_int $2
				local start=$Reply
				to_int $3
				REPLY=s${${1#s}:$start:$REPLY} ;;
			a*) to_ary $1
				to_int $2; shift $REPLY reply
				to_int $3; shift -p $(($#reply - REPLY)) reply
				new_ary $reply ;;
			*) die "unknown argument to $fn: $1" ;;
			esac ;;

		## Arity 4
		S) case $1 in
			s*) to_int $2; local start=$REPLY
				to_int $3; local len=$REPLY
				to_str $4
				REPLY=${1:0:$((start+1))}$REPLY${1:$((start+1+len))} ;;
			a*) to_ary $1; local answer=($reply)
				to_int $2; local start=$REPLY
				to_int $3; local len=$REPLY
				to_ary $4;
				answer[start+1,start+len]=($reply)
				new_ary $answer ;;
			*) die "unknown argument to $fn: $1" ;;
			esac ;;
		*) die "BUG: unknown function $fn" ;;
	esac
	return 0
}

################################################################################
#                          Handle command-line input                           #
################################################################################

usage () cat <<<"usage: ${ZSH_SCRIPT:t} [-h] (-e expr | -f file)"

case $# in
	0) set -- -f /dev/stdin ;&
	2) case $1 in
			-f) 2="$(<$2)" || exit ;&
			-e) eval_kn $2; exit ;;
			-h) usage; exit ;;
			# in the error case, fall thru to the usage
		esac ;&
	*) usage >&2; exit 1
esac


exit
## The list of variables that exist.
typeset -gA variables

# TODO: does string parsing handle `\r\n`?`
next_expr <<EOS
   #ls 
"ab_$(printf '\r\n')
q'_a
'
 'def'
  #def'
+ ~ 1 2
0abc01T
123a  1b
EOS

echo "{$Reply} {$Line}"
exit
