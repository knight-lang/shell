#!/bin/dash

################################################################################
#                                    Setup                                     #
################################################################################

## Set options
set -o nounset
set -o noglob

# Naming scheme:
# READ_ONLY
# GlobalVariables
# local_variable
# _variable_that_doesnt_need_to_be_local

readonly ARY_SEP=: # "$(printf %d \'28)"
readonly SCRIPT_NAME=${0##*/}
readonly NEWLINE='
'

## Print out a message and exit the program
die () {
	fmt=$1
	shift
	printf "%s: $fmt\\n" "$SCRIPT_NAME" "$@"
	exit 1
}

TODO () { die "TODO: $*"; }

################################################################################
#                                    Arrays                                    #
################################################################################

next_ary_eval_idx=0

new_ary () {
	Reply=a$#

	for _arg; do
		if [ "${_arg#a}" = "$_arg" ]; then
			Reply=$Reply$ARY_SEP$_arg
		else
			# readonly
			eval "r$next_ary_eval_idx=\$_arg"
			Reply=$Reply${ARY_SEP}r$next_ary_eval_idx
			next_ary_eval_idx=$((next_ary_eval_idx + 1))
		fi
	done
}

alias explode-array-at-arg1='
_old_IFS=$IFS
IFS=$ARY_SEP
set -o noglob
set -- $1
shift # delete `aN` prefix
set +o noglob
IFS=$_old_IFS
'

ary_join () {
	# We have to have `result` be local because `to_str` will clobber `Reply`.
	local sep=$1 result=
	shift

	explode-array-at-arg1

	for _arg; do
		to_str "$_arg"
		result=$result${result:+$sep}$Reply
	done

	Reply=$result
}

################################################################################
#                                 Conversions                                  #
################################################################################

## Converts its argument to a string, storing the result in $Reply
to_str () case $1 in
	[si]*) Reply=${1#?} ;;
	T)     Reply=true ;;
	F)     Reply=false ;;
	N)     Reply= ;;
	r*)    eval "to_str \$$1" ;;
	a*)    ary_join "$NEWLINE" "$1" ;;
	*) die "unknown type for to_str: $1" ;;
esac

## Converts its argument to an integer, storing the result in $Reply
to_int () case $1 in
	s*) case ${1%s} in
		-*[!0-9]*) TODO ;;
		[!-]*[!0-9]*) TODO ;;
		*) Reply=i${1%s} ;; # TODO: there's no way this works
		esac ;;
	[FN]) Reply=0 ;;
	T)    Reply=1 ;;
	i*)   Reply=${1#i} ;;
	r*)   eval "to_int \$$1" ;;
	a*)   Reply=${1#a}
	      Reply=${Reply%%"$ARY_SEP"*} ;;
	*) die "unknown type for to_int: $1" ;;
esac

## Returns 0 if its argument is truthy
to_bool () case $1 in [sFN]|[ia]0) false; esac

# Converts its argument to an array, storing the result in $Reply
to_ary () case $1 in
	[sFN]) Reply=a0 ;; # Note that we handle the empty string case here
	T) Reply=a1:T ;;
	s*) _str=${1#s}
		Reply=a${#_str}
		while [ -n "$_str" ]; do
			Reply=$Reply${ARY_SEP}s$(printf %c "$_str")
			_str=${_str#?}
		done ;;
	a*)    Reply=$1 ;;
	*) die "unknown type for $0: $1" ;;
esac

################################################################################
#                                  Utilities                                   #
################################################################################

## Sets `Reply` to `T` or `F` based on the exit status of the last command.
newbool () if [ $? -ne 0 ]; then Reply=F; else Reply=T; fi

## Dumps its argument to stdout.
dump () case $1 in
	T) printf true ;;
	F) printf false ;;
	N) printf null ;;
	i) printf ${1%i} ;;
	s*) printf %sx "${1#s}" | sed '
:s
$!N;$!bs
s/\\/\\\\/g;s/\t/\\t/g;s/\r/\\r/g;s/"/\\"/g;s/\n/\\n/g
s/^/"/; s/x$/"/' ;;
	a0) printf \[\] ;;
	a*) 
		printf \[
		explode-array-at-arg1

		dump "$1"; shift
		for _arg; do
			printf ', '
			dump "$_arg"
		done
		printf \]
		;;
	r*) eval "dump \$$1" ;;
	*) die "unknown type for dump: $1" ;;
esac

## Returns whether its arguments are equal, ie knight's `?` function
are_equal () {
	# expand out `r` references
	[ "${1#r}" != "$1" ] && eval "set -- \$$1 \$2"
	[ "${2#r}" != "$2" ] && eval "set -- \$1 \$$2"

	# If they're identical, then they're equal.
	[ "$1" = "$2" ] && return


	# If either element isn't an array, then they're not equal; arrays are the
	# only type which require more than a simple `=` comparison
	if [ "${1#a}" = "$1" ] || [ "${2#a}" = "$2" ]; then
		return 1
	fi

	# They're both arrays. Given how we've checked for direct equality, the only
	# things that we need to check for now are `r*`s

	while [ -n "$1" ] && [ -n "$2" ]; do
		_prefix1="${1%%"$ARY_SEP"*}"; _tmp1=${1#"$_prefix1"}; _tmp1=${_tmp1#"$ARY_SEP"}
		_prefix2="${2%%"$ARY_SEP"*}"; _tmp2=${2#"$_prefix2"}; _tmp2=${_tmp2#"$ARY_SEP"}
		set -- "$_tmp1" "$_tmp2"

		# Hey they're the same, we're good!
		[ "$_prefix1" = "$_prefix2" ] && continue

		# Hm, one of them isn't a reference, looks like they're not the same
		if [ "${_prefix1#r}" = "$_prefix1" ] || [ "${_prefix1#r}" = "$_prefix1" ]; then
			return 1
		fi

		# Both are references, test them out
		are_equal "$_prefix1" "$_prefix2" || return
	done
}



to_ary sAB\"
new_ary s1 s2 $Reply
q=$Reply
to_ary sAB\"
new_ary s1 s2 $Reply
r=$Reply
are_equal "$q" "$r"
echo $?
# dump $Reply
# exit
