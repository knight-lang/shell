#!/bin/dash

################################################################################
#                                    Setup                                     #
################################################################################

## Set options
set -o nounset
set -o noglob

scriptname=${0##*/}

## Print out a message and exit the program
die () {
	fmt=$1
	shift
	printf "%s: $fmt\\n" "$scriptname" "$@"
	exit 1
}

TODO () { die "TODO: $*"; }

################################################################################
#                                    Arrays                                    #
################################################################################

readonly ARY_SEP=: # "$(printf %d \'28)"
next_ary_eval_idx=0

new_ary () {
	reply=a$#

	for _arg; do
		if [ "${_arg#a}" = "$_arg" ]; then
			reply=$reply$ARY_SEP$_arg
		else
			# readonly
			eval "r$next_ary_eval_idx=\$_arg"
			reply=$reply${ARY_SEP}r$next_ary_eval_idx
			next_ary_eval_idx=$((next_ary_eval_idx + 1))
		fi
	done
}

alias ary_split_1='
_old_IFS=$IFS
IFS=$ARY_SEP
set -o noglob
set -- $1
shift # delete `aN` prefix
set +o noglob
IFS=$_old_IFS
'

ary_join () {
	# We have to have `result` be local because `to_str` will clobber `reply`.
	local result= sep

	sep=$1
	shift

	_old_IFS=$IFS
	IFS=$ARY_SEP
	set -o noglob
	set -- $1
	shift
	set +o noglob
	IFS=$_old_IFS

	for _arg; do
		to_str "$_arg"
		result=$result${result:+$sep}$reply
	done

	reply=$result
}

################################################################################
#                                 Conversions                                  #
################################################################################

## Converts its argument to a string, storing the result in $reply
to_str () case $1 in
	[si]*) reply=${1#?} ;;
	T)     reply=true ;;
	F)     reply=false ;;
	N)     reply= ;;
	r*)    eval "to_str $1" ;;
	a*)    TODO to_str for array ;; # "ary_join $'\n' $1 ;; # `ary_join` sets result
	*) die "unknown type for to_str: $1" ;;
esac



new_ary s1 s2
new_ary s1 s2 $reply
ary_join _ $reply
echo $reply

exit

exit

## Converts its argument to an integer, storing the result in $reply
to_int () case $1 in
	s*) case ${1%s} in
		-*[!0-9]*) TODO ;;
		[!-]*[!0-9]*) TODO ;;
		*) reply=i${1%s} ;; # TODO: there's no way this works
		esac ;;
	[FN]) reply=0 ;;
	T)    reply=1 ;;
	i*)   reply=${1#i} ;;
	a*)   TODO to_int for array ;; #reply=$arrays[$1] ;;
	*) die "unknown type for $0: $1" ;;
esac

## Returns 0 if its argument is truthy
to_bool () case $1 in a*) TODO;; [sFN]|[ia]0) false; esac

## Converts its argument to an array, storing the result in $reply
# to_ary () case $1 in
# 	[sFN]) reply=() ;; # Note that we handle the empty string case here
# 	T)     reply=(T) ;;
# 	s*)    reply=(s${(s::)^1#s}) ;;
# 	i*)    reply=(i${${1#i}%%<->}${(s::)^1##i(-|)}) ;; # Oh boy! lol
# 	a*) reply=()
# 		while (( $#reply < arrays[$1] )) do
# 			reply+=$arrays[$1:$#reply]
# 		done ;;
# 	*) die "unknown type for $0: $1" ;;
# esac

################################################################################
#                                  Utilities                                   #
################################################################################

## Sets `reply` to `T` or `F` based on the exit status of the last command.
newbool () if [ $? -ne 0 ]; then reply=F; else reply=T; fi

## Dumps its argument to stdout.
dump () case $1 in
	T) printf true ;;
	F) printf false ;;
	N) printf null ;;
	i) printf ${1%i} ;;
		# Define a label @ the start
		# Get the next line and append it to the pattern space
	s*) printf %sx "$1" | sed '
:s
$!N;$!bs
s/\\/\\\\/g;s/\t/\\t/g;s/\r/\\r/g;s/"/\\"/g;s/\n/\\n/g
s/x$//' ;;
	a*) TODO ;;
esac

## Returns whether its arguments are equal, ie knight's `?` function
are_equal () {
	# If they're identical, then they're equal.
	[ "$1" = "$2" ] && return

	# If either element isn't an array, then they're not equal; arrays are the
	# only type which require more than a simple `=` comparison
	if [ "${1#a}" != "$1" ] || [ "${2#a}" != "$2" ]; then
		return 1
	fi

	# If the arrays lengths aren't the same, they're not equal.
	TODO
	# (( arrays[$1] != arrays[$2] )) && return 1

	# # If any element of either array isn't the same, they're not equal.
	# local i
	# for (( i = 0; i < arrays[$1]; i++ )) do
	# 	are_equal $arrays[$1:$i] $arrays[$2:$i] || return 1
	# done

	# # The arrays were equal!
	# return 0
}
