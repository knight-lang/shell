#!/bin/dash

################################################################################
#                                    Setup                                     #
################################################################################

## Set options
set -o nounset
set -o noglob

# Naming scheme:
# READ_ONLY
# Global_Variables
# local_variable
# _variable_that_doesnt_need_to_be_local

## Values:
# i-?\d+                   - integer
# s.*                      - string
# [TFN]                    - true/false/null
# v[a-z_][a-z0-9_]         - variable
# a(\d+)(${ARY_SEP}value)* - array; \1 is len, \2+ is elements. value cannot be an ast
# A(\d+)                   - array ref; `eval`ing it will give you the original array
# f(.)(${FN_SEP}value)*    - function; \1 is name, \2+ are arguments.
# F(\d+)                   - fn ref, `eval`ing it will give you the original AST
##

readonly ARY_SEP=: # "$(printf %d \'28)"
readonly FN_SEP=\; # "$(printf %d \'29)"; needs to be diff from ARY_SEP
readonly SCRIPT_NAME=${0##*/}
readonly NEWLINE='
'

## Print out a message and exit the program
die () {
	fmt=$1
	shift
	printf "%s: $fmt\\n" "$SCRIPT_NAME" "$@"
	exit 1
}

TODO () { die "TODO: $*"; }

################################################################################
#                                    Arrays                                    #
################################################################################

Next_Ary_Ref_Idx=0

new_ary () {
	Reply=a$#

	for _arg; do
		if [ "${_arg#a}" = "$_arg" ]; then
			Reply=$Reply$ARY_SEP$_arg
		else
			# readonly
			eval "A$Next_Ary_Ref_Idx=\$_arg"
			Reply=$Reply${ARY_SEP}A$Next_Ary_Ref_Idx
			Next_Ary_Ref_Idx=$((Next_Ary_Ref_Idx + 1))
		fi
	done
}

alias explode-array-at-arg1='
_old_IFS=$IFS
IFS=$ARY_SEP
set -o noglob
set -- $1
shift # delete `aN` prefix
set +o noglob
IFS=$_old_IFS
'

ary_join () {
	# We have to have `result` be local because `to_str` will clobber `Reply`.
	local sep=$1 result=
	shift

	explode-array-at-arg1

	for _arg; do
		to_str "$_arg"
		result=$result${result:+$sep}$Reply
	done

	Reply=$result
}

################################################################################
#                                 Conversions                                  #
################################################################################

## Converts its argument to a string, storing the result in $Reply
to_str () case $1 in
	[si]*) Reply=${1#?} ;;
	T)     Reply=true ;;
	F)     Reply=false ;;
	N)     Reply= ;;
	A*)    eval "to_str \$$1" ;;
	a*)    ary_join "$NEWLINE" "$1" ;;
	*) die "unknown type for to_str: $1" ;;
esac

## Converts its argument to an integer, storing the result in $Reply
to_int () case $1 in
	s*) case ${1%s} in
		-*[!0-9]*) TODO ;;
		[!-]*[!0-9]*) TODO ;;
		*) Reply=i${1%s} ;; # TODO: there's no way this works
		esac ;;
	[FN]) Reply=0 ;;
	T)    Reply=1 ;;
	i*)   Reply=${1#i} ;;
	A*)   eval "to_int \$$1" ;;
	a*)   Reply=${1#a}
	      Reply=${Reply%%"$ARY_SEP"*} ;;
	*) die "unknown type for to_int: $1" ;;
esac

## Returns 0 if its argument is truthy
to_bool () case $1 in [sFN]|[ia]0) false; esac

# Converts its argument to an array, storing the result in $Reply
to_ary () case $1 in
	[sFN]) Reply=a0 ;; # Note that we handle the empty string case here
	T) Reply=a1:T ;;
	s*) _str=${1#s}
		Reply=a${#_str}
		while [ -n "$_str" ]; do
			Reply=$Reply${ARY_SEP}s$(printf %c "$_str")
			_str=${_str#?}
		done ;;
	a*)    Reply=$1 ;;
	*) die "unknown type for $0: $1" ;;
esac

################################################################################
#                                  Utilities                                   #
################################################################################

## Sets `Reply` to `T` or `F` based on the exit status of the last command.
newbool () if [ $? -ne 0 ]; then Reply=F; else Reply=T; fi

## Dumps its argument to stdout.
dump () case $1 in
	T) printf true ;;
	F) printf false ;;
	N) printf null ;;
	i) printf ${1%i} ;;
	s*) printf %sx "${1#s}" | sed '
:s
$!N;$!bs
s/\\/\\\\/g;s/\t/\\t/g;s/\r/\\r/g;s/"/\\"/g;s/\n/\\n/g
s/^/"/; s/x$/"/' ;;
	a0) printf \[\] ;;
	a*) 
		printf \[
		explode-array-at-arg1

		dump "$1"; shift
		for _arg; do
			printf ', '
			dump "$_arg"
		done
		printf \]
		;;
	A*) eval "dump \$$1" ;;
	*) die "unknown type for dump: $1" ;;
esac

## Returns whether its arguments are equal, ie knight's `?` function
are_equal () {
	# expand out `A` references
	[ "${1#A}" != "$1" ] && eval "set -- \$$1 \$2"
	[ "${2#A}" != "$2" ] && eval "set -- \$1 \$$2"

	# If they're identical, then they're equal.
	[ "$1" = "$2" ] && return


	# If either element isn't an array, then they're not equal; arrays are the
	# only type which require more than a simple `=` comparison
	if [ "${1#a}" = "$1" ] || [ "${2#a}" = "$2" ]; then
		return 1
	fi

	# They're both arrays. Given how we've checked for direct equality, the only
	# things that we need to check for now are `A*`s. We also can't explode, as
	# we have two arrays to deal with. lovely :-(

	while [ -n "$1" ] && [ -n "$2" ]; do
		_prefix1="${1%%"$ARY_SEP"*}"; _tmp1=${1#"$_prefix1"}; _tmp1=${_tmp1#"$ARY_SEP"}
		_prefix2="${2%%"$ARY_SEP"*}"; _tmp2=${2#"$_prefix2"}; _tmp2=${_tmp2#"$ARY_SEP"}
		set -- "$_tmp1" "$_tmp2"

		# Hey they're the same, we're good!
		[ "$_prefix1" = "$_prefix2" ] && continue

		# Hm, one of them isn't a reference, looks like they're not the same
		if [ "${_prefix1#A}" = "$_prefix1" ] || [ "${_prefix1#A}" = "$_prefix1" ]; then
			return 1
		fi

		# Both are references, test them out
		are_equal "$_prefix1" "$_prefix2" || return
	done
}

## Sets $Reply to `-1`, `0`, or `1` depending on whether the first argument is
# smaller than, equal to or greater than the second argument.
compare () case $1 in
	s*) to_str "$2"; if [ "${1#s}" \< "$Reply" ]; then
			Reply=-1
		else
			[ "${1#s}" = "$Reply" ]
			Reply=$?
		fi ;;
	T) to_bool "$2"; Reply=$?;;
	F) to_bool "$2"; Reply=$(( - ! $? ));; # The `?` here is actually `$?`
	i*) to_int "$2"; if [ "${1#i}" -lt "$Reply" ]; then
			Reply=-1
		else
			[ "${1#i}" -eq "$Reply" ]
			Reply=$?
		fi ;;
	a*) to_ary "$2"

	_prefix1="${1%%"$ARY_SEP"*}"; _tmp1=${1#"$_prefix1"}; _tmp1=${_tmp1#"$ARY_SEP"}
	_prefix2="${2%%"$ARY_SEP"*}"; _tmp2=${2#"$_prefix2"}; _tmp2=${_tmp2#"$ARY_SEP"}
	set -- "$_tmp1" "$_tmp2"

	local len1=${_prefix1#a} len2=${_prefix2#a}
	
	while [ -n "$1" ] && [ -n "$2" ]; do
		_prefix1="${1%%"$ARY_SEP"*}"; _tmp1=${1#"$_prefix1"}; _tmp1=${_tmp1#"$ARY_SEP"}
		_prefix2="${2%%"$ARY_SEP"*}"; _tmp2=${2#"$_prefix2"}; _tmp2=${_tmp2#"$ARY_SEP"}
		set -- "$_tmp1" "$_tmp2"

		compare "$_prefix1" "$_prefix2"
		[ $Reply = 0 ] || return 0
	done
	compare i$len1 i$len2 ;;
	*) die "unknown type for compare: $1" ;;
esac

################################################################################
#                                   Parsing                                    #
################################################################################

arity () case $1 in
	[PR]) Reply=0 ;;
	[][\$OEBCQ\!LD,A\~]) Reply=1 ;;
	[-+\*/%\^\?\<\>\&\|\;\=W]) Reply=2 ;;
	[GI]) Reply=3 ;;
	S) Reply=4 ;;
	*) die 'unknown function: %s' "$1" ;;
esac

Next_Fn_Ref_Idx=0
parse_fn () {
	local arity result="f$1"

	arity "$1"
	arity=$Reply

	while [ $arity -ne 0 ]; do
		next_expr || return
		# Expression wasn't an ast, just assign it 
		if [ "${Reply#f}" = "$Reply" ]; then
			result="$result$FN_SEP$Reply"
		else
			# Expression was a function, we have to get a refernece to it
			eval "F$Next_Fn_Ref_Idx=\$Reply"
			result=$result${FN_SEP}F$Next_Fn_Ref_Idx
			Next_Fn_Ref_Idx=$((Next_Fn_Ref_Idx + 1))
		fi

		arity=$(( arity - 1 ))
	done
	Reply=$result

	# Reply=A

	# # Setup local variables; `arity`` needs to be on another line because it
	# # relies on `ast` from the line before.
	# local ast=${REPLY#f}
	# local arity=$arities[$ast]

	# # Parse out the arguments
	# while (( arity-- )) do
	# 	next_ast || die "missing argument $((arities[${ast:0:1}] - arity))" \
	# 	                "for function ${(qq)ast:0:1}"
	# 	ast+=$AST_FIELD_SEP$REPLY
	# done

	# # Add the AST to the list
	# asts+=($ast)

	# # Set `$REPLY` to the current AST.
	# REPLY=A$#asts

}
Line=

next_expr () {
	# Strip leading whitespace and comments
	while
		Line=$(printf %s "$Line" | sed 's/^[[:blank:]:(){}]*//; /^#/d')
		[ -z "$Line" ]
	do
		IFS= read -r Line
	done

	# Parse out the token
	case $Line in
		# Integers; cant use `0-9` cause it's locale-dependent technically
		[0123456789]*)
			Reply=i${Line%%[!0123456789]*}
			Line=${Line#"${Reply#?}"} ;;

		# Variables
		[abcdefghijklmnopqrstuvwxyz_]*)
			Reply=v${Line%%[!abcdefghijklmnopqrstuvwxyz_0123456789]*}
			Line=${Line#"${Reply#?}"} ;;

		# Strings; this have to be handled specially cause of multilined stuff
		[\'\"]*)
			_quote=$(printf %c "$Line")
			Line=${Line#?}
			while [ "${Line#*$_quote}" = "$Line" ]; do
				IFS= read -r _tmp || die "missing ending $_quote quote."
				Line=${Line}${NEWLINE}${_tmp}
			done
			
			# while 
			echo "{$_tmp}" "[$Line]"
			exit

			# if [ -n "$Line" ]; then
			# 	Line=${Line#?} # Will always be a quote
			# 	return
			# fi

			# while
			# 	Line=$(printf %s "$Line" | sed 's/^[[:blank:]:(){}]*//; /^#/d')
			# 	[ -z "$Line" ]
			# do
			# 	IFS= read -r Line
			# done

			# echo "{$_tmp} [$Line]"
			# exit
			# echo $_tmp
			die "todo: parse strings" ;;

		# Functions
		[][TFNPRBCQDOLAWIGS\+\*\/\%\^\<\>\?\&\|\;\~\=\,-]*)
			Reply=$(printf %c "$Line")

			case $Reply in
				[TFNPRBCQDOLAWIGS])
					_tmp=${Line%%[!ABCDEFGHIJKLMNOPQRSTUVWXYZ_]*}
					Line=${Line#"$_tmp"} ;;
				*)
					Line=${Line#?}
			esac

			case $Reply in
				@) Reply=a0 ;;
				[TFN]) ;;
				*) parse_fn "$Reply"
			esac ;;
		*) die "unknown token start: '%c'" "$Line"
	esac
}


# TODO: does string parsing handle `\r\n`?`
next_expr <<EOS
   #ls 
'ab_$(printf '\r\n')
q'_a
'
 'def'
  #def'
+ ~ 1 2
0abc01T
123a  1b
EOS
echo "{$Reply} {$Line}"
echo $F0
exit
